/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* MExpression := expr=Expression $
* Expression := Record | MetaExpression
* Record := '{' entries={entry=Entry tail={',' entry=Entry}* }? '}'
* Entry := expr={key=STRING value={':' expr=Expression}? | '\[' key=STRING ',' alias=STRING '\]'}
* MetaExpression := expr={LogicalOr | Record} tail={op='\?[!?]' expr={LogicalOr | Record}}*
* LogicalOr := expr=LogicalImplication tail={'\|\|' expr=LogicalImplication}*
* LogicalImplication := expr=LogicalAnd tail={op='<?->' expr=LogicalAnd}*
* LogicalAnd := expr=Equality tail={'\&\&' expr=Equality}*
* Equality := expr=Comparison tail={op='<>|==' expr=Comparison}*
* Comparison := expr=BitwiseOr tail={op='<=>|[<>]=?' expr=BitwiseOr}*
* BitwiseOr := expr=BitwiseXor tail={op='\|' expr=BitwiseXor}*
* BitwiseXor := expr=BitwiseAnd tail={op='\?' !'[!:]' expr=BitwiseAnd}*
* BitwiseAnd := expr=Shift tail={op='\&' expr=Shift}*
* Shift := expr=Additive tail={op='<<|>>>?' expr=Additive}*
* Additive := expr=Multiplicative tail={op='[+-]' expr=Multiplicative}*
* Multiplicative := expr=Exponential tail={op='[*%\\]|[+\/-]?\/' expr=Exponential}*
* Exponential := expr=Composition tail={'\^' expr=Exponential}?
* Composition := expr=HighOrderFunction tail={';' expr=Composition}?
* HighOrderFunction := expr=Atom tail={op='=>>|=<=|=<<' expr=HighOrderFunction}?
* Atom := op='[~+-]'? expr={Primitive | Evaluation | Vector}
* Vector := '\[' items=Items? '\]'
* FVector := '\(' items=Items? '\)'
* Items := head=Expression tail={',' expr=Expression}* asList=','?
* Evaluation := eager='!'? expr={Lambda | label=MARKER vector={Vector | FVector}?}
* Lambda := '\.' expr={'\[' body=LambdaBody  '\]' | '\(' body=LambdaBody '\)'}
* LambdaBody := parameters=Parameters? ';' body=Expression partial={';' args=Vector}?
* Parameters := mark=MARKER tail={',' mark=MARKER}* variadic='\*'?
* Primitive := NUMBER | STRING | TRILEAN
* NUMBER := text='[0-9]*\.[0-9]+|[0-9]+\.?'
* 	.value = number { return parseFloat(this.text); }
* STRING := text={'"(\\"|[^\\"])*"' | '\'(\\\'|[^\\\'])*\''}
*     .value = string { return this.text.substring(1, this.text.length - 1); }
* MARKER := text='@?[a-zA-Z_][a-zA-Z0-9_]*|[?!|<>&=:+*%\\\/~$private _\^-]+' !TRILEAN
*     .value = string { return this.text; }
* TRILEAN := text='false|nil|true'
*     .value = number { return this.text === "false" ? -1 : this.text === "true" ? 1 : 0; }
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    MExpression,
    Expression_1,
    Expression_2,
    Record,
    Record_$0,
    Record_$0_$0,
    Entry,
    Entry_$0_1,
    Entry_$0_2,
    Entry_$0_$0,
    MetaExpression,
    MetaExpression_$0_1,
    MetaExpression_$0_2,
    MetaExpression_$1,
    MetaExpression_$1_$0_1,
    MetaExpression_$1_$0_2,
    LogicalOr,
    LogicalOr_$0,
    LogicalImplication,
    LogicalImplication_$0,
    LogicalAnd,
    LogicalAnd_$0,
    Equality,
    Equality_$0,
    Comparison,
    Comparison_$0,
    BitwiseOr,
    BitwiseOr_$0,
    BitwiseXor,
    BitwiseXor_$0,
    BitwiseAnd,
    BitwiseAnd_$0,
    Shift,
    Shift_$0,
    Additive,
    Additive_$0,
    Multiplicative,
    Multiplicative_$0,
    Exponential,
    Exponential_$0,
    Composition,
    Composition_$0,
    HighOrderFunction,
    HighOrderFunction_$0,
    Atom,
    Atom_$0_1,
    Atom_$0_2,
    Atom_$0_3,
    Vector,
    FVector,
    Items,
    Items_$0,
    Evaluation,
    Evaluation_$0_1,
    Evaluation_$0_2,
    Evaluation_$0_$0_1,
    Evaluation_$0_$0_2,
    Lambda,
    Lambda_$0_1,
    Lambda_$0_2,
    LambdaBody,
    LambdaBody_$0,
    Parameters,
    Parameters_$0,
    Primitive_1,
    Primitive_2,
    Primitive_3,
    NUMBER,
    STRING,
    STRING_$0_1,
    STRING_$0_2,
    MARKER,
    TRILEAN,
    $EOF,
}
export interface MExpression {
    kind: ASTKinds.MExpression;
    expr: Expression;
}
export type Expression = Expression_1 | Expression_2;
export type Expression_1 = Record;
export type Expression_2 = MetaExpression;
export interface Record {
    kind: ASTKinds.Record;
    entries: Nullable<Record_$0>;
}
export interface Record_$0 {
    kind: ASTKinds.Record_$0;
    entry: Entry;
    tail: Record_$0_$0[];
}
export interface Record_$0_$0 {
    kind: ASTKinds.Record_$0_$0;
    entry: Entry;
}
export interface Entry {
    kind: ASTKinds.Entry;
    expr: Entry_$0;
}
export type Entry_$0 = Entry_$0_1 | Entry_$0_2;
export interface Entry_$0_1 {
    kind: ASTKinds.Entry_$0_1;
    key: STRING;
    value: Nullable<Entry_$0_$0>;
}
export interface Entry_$0_2 {
    kind: ASTKinds.Entry_$0_2;
    key: STRING;
    alias: STRING;
}
export interface Entry_$0_$0 {
    kind: ASTKinds.Entry_$0_$0;
    expr: Expression;
}
export interface MetaExpression {
    kind: ASTKinds.MetaExpression;
    expr: MetaExpression_$0;
    tail: MetaExpression_$1[];
}
export type MetaExpression_$0 = MetaExpression_$0_1 | MetaExpression_$0_2;
export type MetaExpression_$0_1 = LogicalOr;
export type MetaExpression_$0_2 = Record;
export interface MetaExpression_$1 {
    kind: ASTKinds.MetaExpression_$1;
    op: string;
    expr: MetaExpression_$1_$0;
}
export type MetaExpression_$1_$0 = MetaExpression_$1_$0_1 | MetaExpression_$1_$0_2;
export type MetaExpression_$1_$0_1 = LogicalOr;
export type MetaExpression_$1_$0_2 = Record;
export interface LogicalOr {
    kind: ASTKinds.LogicalOr;
    expr: LogicalImplication;
    tail: LogicalOr_$0[];
}
export interface LogicalOr_$0 {
    kind: ASTKinds.LogicalOr_$0;
    expr: LogicalImplication;
}
export interface LogicalImplication {
    kind: ASTKinds.LogicalImplication;
    expr: LogicalAnd;
    tail: LogicalImplication_$0[];
}
export interface LogicalImplication_$0 {
    kind: ASTKinds.LogicalImplication_$0;
    op: string;
    expr: LogicalAnd;
}
export interface LogicalAnd {
    kind: ASTKinds.LogicalAnd;
    expr: Equality;
    tail: LogicalAnd_$0[];
}
export interface LogicalAnd_$0 {
    kind: ASTKinds.LogicalAnd_$0;
    expr: Equality;
}
export interface Equality {
    kind: ASTKinds.Equality;
    expr: Comparison;
    tail: Equality_$0[];
}
export interface Equality_$0 {
    kind: ASTKinds.Equality_$0;
    op: string;
    expr: Comparison;
}
export interface Comparison {
    kind: ASTKinds.Comparison;
    expr: BitwiseOr;
    tail: Comparison_$0[];
}
export interface Comparison_$0 {
    kind: ASTKinds.Comparison_$0;
    op: string;
    expr: BitwiseOr;
}
export interface BitwiseOr {
    kind: ASTKinds.BitwiseOr;
    expr: BitwiseXor;
    tail: BitwiseOr_$0[];
}
export interface BitwiseOr_$0 {
    kind: ASTKinds.BitwiseOr_$0;
    op: string;
    expr: BitwiseXor;
}
export interface BitwiseXor {
    kind: ASTKinds.BitwiseXor;
    expr: BitwiseAnd;
    tail: BitwiseXor_$0[];
}
export interface BitwiseXor_$0 {
    kind: ASTKinds.BitwiseXor_$0;
    op: string;
    expr: BitwiseAnd;
}
export interface BitwiseAnd {
    kind: ASTKinds.BitwiseAnd;
    expr: Shift;
    tail: BitwiseAnd_$0[];
}
export interface BitwiseAnd_$0 {
    kind: ASTKinds.BitwiseAnd_$0;
    op: string;
    expr: Shift;
}
export interface Shift {
    kind: ASTKinds.Shift;
    expr: Additive;
    tail: Shift_$0[];
}
export interface Shift_$0 {
    kind: ASTKinds.Shift_$0;
    op: string;
    expr: Additive;
}
export interface Additive {
    kind: ASTKinds.Additive;
    expr: Multiplicative;
    tail: Additive_$0[];
}
export interface Additive_$0 {
    kind: ASTKinds.Additive_$0;
    op: string;
    expr: Multiplicative;
}
export interface Multiplicative {
    kind: ASTKinds.Multiplicative;
    expr: Exponential;
    tail: Multiplicative_$0[];
}
export interface Multiplicative_$0 {
    kind: ASTKinds.Multiplicative_$0;
    op: string;
    expr: Exponential;
}
export interface Exponential {
    kind: ASTKinds.Exponential;
    expr: Composition;
    tail: Nullable<Exponential_$0>;
}
export interface Exponential_$0 {
    kind: ASTKinds.Exponential_$0;
    expr: Exponential;
}
export interface Composition {
    kind: ASTKinds.Composition;
    expr: HighOrderFunction;
    tail: Nullable<Composition_$0>;
}
export interface Composition_$0 {
    kind: ASTKinds.Composition_$0;
    expr: Composition;
}
export interface HighOrderFunction {
    kind: ASTKinds.HighOrderFunction;
    expr: Atom;
    tail: Nullable<HighOrderFunction_$0>;
}
export interface HighOrderFunction_$0 {
    kind: ASTKinds.HighOrderFunction_$0;
    op: string;
    expr: HighOrderFunction;
}
export interface Atom {
    kind: ASTKinds.Atom;
    op: Nullable<string>;
    expr: Atom_$0;
}
export type Atom_$0 = Atom_$0_1 | Atom_$0_2 | Atom_$0_3;
export type Atom_$0_1 = Primitive;
export type Atom_$0_2 = Evaluation;
export type Atom_$0_3 = Vector;
export interface Vector {
    kind: ASTKinds.Vector;
    items: Nullable<Items>;
}
export interface FVector {
    kind: ASTKinds.FVector;
    items: Nullable<Items>;
}
export interface Items {
    kind: ASTKinds.Items;
    head: Expression;
    tail: Items_$0[];
    asList: Nullable<string>;
}
export interface Items_$0 {
    kind: ASTKinds.Items_$0;
    expr: Expression;
}
export interface Evaluation {
    kind: ASTKinds.Evaluation;
    eager: Nullable<string>;
    expr: Evaluation_$0;
}
export type Evaluation_$0 = Evaluation_$0_1 | Evaluation_$0_2;
export type Evaluation_$0_1 = Lambda;
export interface Evaluation_$0_2 {
    kind: ASTKinds.Evaluation_$0_2;
    label: MARKER;
    vector: Nullable<Evaluation_$0_$0>;
}
export type Evaluation_$0_$0 = Evaluation_$0_$0_1 | Evaluation_$0_$0_2;
export type Evaluation_$0_$0_1 = Vector;
export type Evaluation_$0_$0_2 = FVector;
export interface Lambda {
    kind: ASTKinds.Lambda;
    expr: Lambda_$0;
}
export type Lambda_$0 = Lambda_$0_1 | Lambda_$0_2;
export interface Lambda_$0_1 {
    kind: ASTKinds.Lambda_$0_1;
    body: LambdaBody;
}
export interface Lambda_$0_2 {
    kind: ASTKinds.Lambda_$0_2;
    body: LambdaBody;
}
export interface LambdaBody {
    kind: ASTKinds.LambdaBody;
    parameters: Nullable<Parameters>;
    body: Expression;
    partial: Nullable<LambdaBody_$0>;
}
export interface LambdaBody_$0 {
    kind: ASTKinds.LambdaBody_$0;
    args: Vector;
}
export interface Parameters {
    kind: ASTKinds.Parameters;
    mark: MARKER;
    tail: Parameters_$0[];
    variadic: Nullable<string>;
}
export interface Parameters_$0 {
    kind: ASTKinds.Parameters_$0;
    mark: MARKER;
}
export type Primitive = Primitive_1 | Primitive_2 | Primitive_3;
export type Primitive_1 = NUMBER;
export type Primitive_2 = STRING;
export type Primitive_3 = TRILEAN;
export class NUMBER {
    public kind: ASTKinds.NUMBER = ASTKinds.NUMBER;
    public text: string;
    public value: number;
    constructor(text: string){
        this.text = text;
        this.value = ((): number => {
        return parseFloat(this.text);
        })();
    }
}
export class STRING {
    public kind: ASTKinds.STRING = ASTKinds.STRING;
    public text: STRING_$0;
    public value: string;
    constructor(text: STRING_$0){
        this.text = text;
        this.value = ((): string => {
        return this.text.substring(1, this.text.length - 1);
        })();
    }
}
export type STRING_$0 = STRING_$0_1 | STRING_$0_2;
export type STRING_$0_1 = string;
export type STRING_$0_2 = string;
export class MARKER {
    public kind: ASTKinds.MARKER = ASTKinds.MARKER;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return this.text;
        })();
    }
}
export class TRILEAN {
    public kind: ASTKinds.TRILEAN = ASTKinds.TRILEAN;
    public text: string;
    public value: number;
    constructor(text: string){
        this.text = text;
        this.value = ((): number => {
        return this.text === "false" ? -1 : this.text === "true" ? 1 : 0;
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$MExpression$memo.clear();
        this.$scope$Expression$memo.clear();
        this.$scope$Record$memo.clear();
        this.$scope$Record_$0$memo.clear();
        this.$scope$Record_$0_$0$memo.clear();
        this.$scope$Entry$memo.clear();
        this.$scope$Entry_$0$memo.clear();
        this.$scope$Entry_$0_$0$memo.clear();
        this.$scope$MetaExpression$memo.clear();
        this.$scope$MetaExpression_$0$memo.clear();
        this.$scope$MetaExpression_$1$memo.clear();
        this.$scope$MetaExpression_$1_$0$memo.clear();
        this.$scope$LogicalOr$memo.clear();
        this.$scope$LogicalOr_$0$memo.clear();
        this.$scope$LogicalImplication$memo.clear();
        this.$scope$LogicalImplication_$0$memo.clear();
        this.$scope$LogicalAnd$memo.clear();
        this.$scope$LogicalAnd_$0$memo.clear();
        this.$scope$Equality$memo.clear();
        this.$scope$Equality_$0$memo.clear();
        this.$scope$Comparison$memo.clear();
        this.$scope$Comparison_$0$memo.clear();
        this.$scope$BitwiseOr$memo.clear();
        this.$scope$BitwiseOr_$0$memo.clear();
        this.$scope$BitwiseXor$memo.clear();
        this.$scope$BitwiseXor_$0$memo.clear();
        this.$scope$BitwiseAnd$memo.clear();
        this.$scope$BitwiseAnd_$0$memo.clear();
        this.$scope$Shift$memo.clear();
        this.$scope$Shift_$0$memo.clear();
        this.$scope$Additive$memo.clear();
        this.$scope$Additive_$0$memo.clear();
        this.$scope$Multiplicative$memo.clear();
        this.$scope$Multiplicative_$0$memo.clear();
        this.$scope$Exponential$memo.clear();
        this.$scope$Exponential_$0$memo.clear();
        this.$scope$Composition$memo.clear();
        this.$scope$Composition_$0$memo.clear();
        this.$scope$HighOrderFunction$memo.clear();
        this.$scope$HighOrderFunction_$0$memo.clear();
        this.$scope$Atom$memo.clear();
        this.$scope$Atom_$0$memo.clear();
        this.$scope$Vector$memo.clear();
        this.$scope$FVector$memo.clear();
        this.$scope$Items$memo.clear();
        this.$scope$Items_$0$memo.clear();
        this.$scope$Evaluation$memo.clear();
        this.$scope$Evaluation_$0$memo.clear();
        this.$scope$Evaluation_$0_$0$memo.clear();
        this.$scope$Lambda$memo.clear();
        this.$scope$Lambda_$0$memo.clear();
        this.$scope$LambdaBody$memo.clear();
        this.$scope$LambdaBody_$0$memo.clear();
        this.$scope$Parameters$memo.clear();
        this.$scope$Parameters_$0$memo.clear();
        this.$scope$Primitive$memo.clear();
        this.$scope$NUMBER$memo.clear();
        this.$scope$STRING$memo.clear();
        this.$scope$STRING_$0$memo.clear();
        this.$scope$MARKER$memo.clear();
        this.$scope$TRILEAN$memo.clear();
    }
    protected $scope$MExpression$memo: Map<number, [Nullable<MExpression>, PosInfo]> = new Map();
    protected $scope$Expression$memo: Map<number, [Nullable<Expression>, PosInfo]> = new Map();
    protected $scope$Record$memo: Map<number, [Nullable<Record>, PosInfo]> = new Map();
    protected $scope$Record_$0$memo: Map<number, [Nullable<Record_$0>, PosInfo]> = new Map();
    protected $scope$Record_$0_$0$memo: Map<number, [Nullable<Record_$0_$0>, PosInfo]> = new Map();
    protected $scope$Entry$memo: Map<number, [Nullable<Entry>, PosInfo]> = new Map();
    protected $scope$Entry_$0$memo: Map<number, [Nullable<Entry_$0>, PosInfo]> = new Map();
    protected $scope$Entry_$0_$0$memo: Map<number, [Nullable<Entry_$0_$0>, PosInfo]> = new Map();
    protected $scope$MetaExpression$memo: Map<number, [Nullable<MetaExpression>, PosInfo]> = new Map();
    protected $scope$MetaExpression_$0$memo: Map<number, [Nullable<MetaExpression_$0>, PosInfo]> = new Map();
    protected $scope$MetaExpression_$1$memo: Map<number, [Nullable<MetaExpression_$1>, PosInfo]> = new Map();
    protected $scope$MetaExpression_$1_$0$memo: Map<number, [Nullable<MetaExpression_$1_$0>, PosInfo]> = new Map();
    protected $scope$LogicalOr$memo: Map<number, [Nullable<LogicalOr>, PosInfo]> = new Map();
    protected $scope$LogicalOr_$0$memo: Map<number, [Nullable<LogicalOr_$0>, PosInfo]> = new Map();
    protected $scope$LogicalImplication$memo: Map<number, [Nullable<LogicalImplication>, PosInfo]> = new Map();
    protected $scope$LogicalImplication_$0$memo: Map<number, [Nullable<LogicalImplication_$0>, PosInfo]> = new Map();
    protected $scope$LogicalAnd$memo: Map<number, [Nullable<LogicalAnd>, PosInfo]> = new Map();
    protected $scope$LogicalAnd_$0$memo: Map<number, [Nullable<LogicalAnd_$0>, PosInfo]> = new Map();
    protected $scope$Equality$memo: Map<number, [Nullable<Equality>, PosInfo]> = new Map();
    protected $scope$Equality_$0$memo: Map<number, [Nullable<Equality_$0>, PosInfo]> = new Map();
    protected $scope$Comparison$memo: Map<number, [Nullable<Comparison>, PosInfo]> = new Map();
    protected $scope$Comparison_$0$memo: Map<number, [Nullable<Comparison_$0>, PosInfo]> = new Map();
    protected $scope$BitwiseOr$memo: Map<number, [Nullable<BitwiseOr>, PosInfo]> = new Map();
    protected $scope$BitwiseOr_$0$memo: Map<number, [Nullable<BitwiseOr_$0>, PosInfo]> = new Map();
    protected $scope$BitwiseXor$memo: Map<number, [Nullable<BitwiseXor>, PosInfo]> = new Map();
    protected $scope$BitwiseXor_$0$memo: Map<number, [Nullable<BitwiseXor_$0>, PosInfo]> = new Map();
    protected $scope$BitwiseAnd$memo: Map<number, [Nullable<BitwiseAnd>, PosInfo]> = new Map();
    protected $scope$BitwiseAnd_$0$memo: Map<number, [Nullable<BitwiseAnd_$0>, PosInfo]> = new Map();
    protected $scope$Shift$memo: Map<number, [Nullable<Shift>, PosInfo]> = new Map();
    protected $scope$Shift_$0$memo: Map<number, [Nullable<Shift_$0>, PosInfo]> = new Map();
    protected $scope$Additive$memo: Map<number, [Nullable<Additive>, PosInfo]> = new Map();
    protected $scope$Additive_$0$memo: Map<number, [Nullable<Additive_$0>, PosInfo]> = new Map();
    protected $scope$Multiplicative$memo: Map<number, [Nullable<Multiplicative>, PosInfo]> = new Map();
    protected $scope$Multiplicative_$0$memo: Map<number, [Nullable<Multiplicative_$0>, PosInfo]> = new Map();
    protected $scope$Exponential$memo: Map<number, [Nullable<Exponential>, PosInfo]> = new Map();
    protected $scope$Exponential_$0$memo: Map<number, [Nullable<Exponential_$0>, PosInfo]> = new Map();
    protected $scope$Composition$memo: Map<number, [Nullable<Composition>, PosInfo]> = new Map();
    protected $scope$Composition_$0$memo: Map<number, [Nullable<Composition_$0>, PosInfo]> = new Map();
    protected $scope$HighOrderFunction$memo: Map<number, [Nullable<HighOrderFunction>, PosInfo]> = new Map();
    protected $scope$HighOrderFunction_$0$memo: Map<number, [Nullable<HighOrderFunction_$0>, PosInfo]> = new Map();
    protected $scope$Atom$memo: Map<number, [Nullable<Atom>, PosInfo]> = new Map();
    protected $scope$Atom_$0$memo: Map<number, [Nullable<Atom_$0>, PosInfo]> = new Map();
    protected $scope$Vector$memo: Map<number, [Nullable<Vector>, PosInfo]> = new Map();
    protected $scope$FVector$memo: Map<number, [Nullable<FVector>, PosInfo]> = new Map();
    protected $scope$Items$memo: Map<number, [Nullable<Items>, PosInfo]> = new Map();
    protected $scope$Items_$0$memo: Map<number, [Nullable<Items_$0>, PosInfo]> = new Map();
    protected $scope$Evaluation$memo: Map<number, [Nullable<Evaluation>, PosInfo]> = new Map();
    protected $scope$Evaluation_$0$memo: Map<number, [Nullable<Evaluation_$0>, PosInfo]> = new Map();
    protected $scope$Evaluation_$0_$0$memo: Map<number, [Nullable<Evaluation_$0_$0>, PosInfo]> = new Map();
    protected $scope$Lambda$memo: Map<number, [Nullable<Lambda>, PosInfo]> = new Map();
    protected $scope$Lambda_$0$memo: Map<number, [Nullable<Lambda_$0>, PosInfo]> = new Map();
    protected $scope$LambdaBody$memo: Map<number, [Nullable<LambdaBody>, PosInfo]> = new Map();
    protected $scope$LambdaBody_$0$memo: Map<number, [Nullable<LambdaBody_$0>, PosInfo]> = new Map();
    protected $scope$Parameters$memo: Map<number, [Nullable<Parameters>, PosInfo]> = new Map();
    protected $scope$Parameters_$0$memo: Map<number, [Nullable<Parameters_$0>, PosInfo]> = new Map();
    protected $scope$Primitive$memo: Map<number, [Nullable<Primitive>, PosInfo]> = new Map();
    protected $scope$NUMBER$memo: Map<number, [Nullable<NUMBER>, PosInfo]> = new Map();
    protected $scope$STRING$memo: Map<number, [Nullable<STRING>, PosInfo]> = new Map();
    protected $scope$STRING_$0$memo: Map<number, [Nullable<STRING_$0>, PosInfo]> = new Map();
    protected $scope$MARKER$memo: Map<number, [Nullable<MARKER>, PosInfo]> = new Map();
    protected $scope$TRILEAN$memo: Map<number, [Nullable<TRILEAN>, PosInfo]> = new Map();
    public matchMExpression($$dpth: number, $$cr?: ErrorTracker): Nullable<MExpression> {
        return this.memoise(
            () => {
                return this.run<MExpression>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Expression>;
                        let $$res: Nullable<MExpression> = null;
                        if (true
                            && ($scope$expr = this.matchExpression($$dpth + 1, $$cr)) !== null
                            && this.match$EOF($$cr) !== null
                        ) {
                            $$res = {kind: ASTKinds.MExpression, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$MExpression$memo,
        );
    }
    public matchExpression($$dpth: number, $$cr?: ErrorTracker): Nullable<Expression> {
        return this.memoise(
            () => {
                return this.choice<Expression>([
                    () => this.matchExpression_1($$dpth + 1, $$cr),
                    () => this.matchExpression_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Expression$memo,
        );
    }
    public matchExpression_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Expression_1> {
        return this.matchRecord($$dpth + 1, $$cr);
    }
    public matchExpression_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Expression_2> {
        return this.matchMetaExpression($$dpth + 1, $$cr);
    }
    public matchRecord($$dpth: number, $$cr?: ErrorTracker): Nullable<Record> {
        return this.memoise(
            () => {
                return this.run<Record>($$dpth,
                    () => {
                        let $scope$entries: Nullable<Nullable<Record_$0>>;
                        let $$res: Nullable<Record> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                            && (($scope$entries = this.matchRecord_$0($$dpth + 1, $$cr)) || true)
                            && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = {kind: ASTKinds.Record, entries: $scope$entries};
                        }
                        return $$res;
                    });
            },
            this.$scope$Record$memo,
        );
    }
    public matchRecord_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Record_$0> {
        return this.memoise(
            () => {
                return this.run<Record_$0>($$dpth,
                    () => {
                        let $scope$entry: Nullable<Entry>;
                        let $scope$tail: Nullable<Record_$0_$0[]>;
                        let $$res: Nullable<Record_$0> = null;
                        if (true
                            && ($scope$entry = this.matchEntry($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Record_$0_$0>(() => this.matchRecord_$0_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Record_$0, entry: $scope$entry, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Record_$0$memo,
        );
    }
    public matchRecord_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Record_$0_$0> {
        return this.memoise(
            () => {
                return this.run<Record_$0_$0>($$dpth,
                    () => {
                        let $scope$entry: Nullable<Entry>;
                        let $$res: Nullable<Record_$0_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                            && ($scope$entry = this.matchEntry($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Record_$0_$0, entry: $scope$entry};
                        }
                        return $$res;
                    });
            },
            this.$scope$Record_$0_$0$memo,
        );
    }
    public matchEntry($$dpth: number, $$cr?: ErrorTracker): Nullable<Entry> {
        return this.memoise(
            () => {
                return this.run<Entry>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Entry_$0>;
                        let $$res: Nullable<Entry> = null;
                        if (true
                            && ($scope$expr = this.matchEntry_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Entry, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Entry$memo,
        );
    }
    public matchEntry_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Entry_$0> {
        return this.memoise(
            () => {
                return this.choice<Entry_$0>([
                    () => this.matchEntry_$0_1($$dpth + 1, $$cr),
                    () => this.matchEntry_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Entry_$0$memo,
        );
    }
    public matchEntry_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Entry_$0_1> {
        return this.run<Entry_$0_1>($$dpth,
            () => {
                let $scope$key: Nullable<STRING>;
                let $scope$value: Nullable<Nullable<Entry_$0_$0>>;
                let $$res: Nullable<Entry_$0_1> = null;
                if (true
                    && ($scope$key = this.matchSTRING($$dpth + 1, $$cr)) !== null
                    && (($scope$value = this.matchEntry_$0_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.Entry_$0_1, key: $scope$key, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchEntry_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Entry_$0_2> {
        return this.run<Entry_$0_2>($$dpth,
            () => {
                let $scope$key: Nullable<STRING>;
                let $scope$alias: Nullable<STRING>;
                let $$res: Nullable<Entry_$0_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && ($scope$key = this.matchSTRING($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && ($scope$alias = this.matchSTRING($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Entry_$0_2, key: $scope$key, alias: $scope$alias};
                }
                return $$res;
            });
    }
    public matchEntry_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Entry_$0_$0> {
        return this.memoise(
            () => {
                return this.run<Entry_$0_$0>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Expression>;
                        let $$res: Nullable<Entry_$0_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchExpression($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Entry_$0_$0, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Entry_$0_$0$memo,
        );
    }
    public matchMetaExpression($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression> {
        return this.memoise(
            () => {
                return this.run<MetaExpression>($$dpth,
                    () => {
                        let $scope$expr: Nullable<MetaExpression_$0>;
                        let $scope$tail: Nullable<MetaExpression_$1[]>;
                        let $$res: Nullable<MetaExpression> = null;
                        if (true
                            && ($scope$expr = this.matchMetaExpression_$0($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<MetaExpression_$1>(() => this.matchMetaExpression_$1($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.MetaExpression, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$MetaExpression$memo,
        );
    }
    public matchMetaExpression_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$0> {
        return this.memoise(
            () => {
                return this.choice<MetaExpression_$0>([
                    () => this.matchMetaExpression_$0_1($$dpth + 1, $$cr),
                    () => this.matchMetaExpression_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$MetaExpression_$0$memo,
        );
    }
    public matchMetaExpression_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$0_1> {
        return this.matchLogicalOr($$dpth + 1, $$cr);
    }
    public matchMetaExpression_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$0_2> {
        return this.matchRecord($$dpth + 1, $$cr);
    }
    public matchMetaExpression_$1($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$1> {
        return this.memoise(
            () => {
                return this.run<MetaExpression_$1>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<MetaExpression_$1_$0>;
                        let $$res: Nullable<MetaExpression_$1> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:\?[!?])`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchMetaExpression_$1_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.MetaExpression_$1, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$MetaExpression_$1$memo,
        );
    }
    public matchMetaExpression_$1_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$1_$0> {
        return this.memoise(
            () => {
                return this.choice<MetaExpression_$1_$0>([
                    () => this.matchMetaExpression_$1_$0_1($$dpth + 1, $$cr),
                    () => this.matchMetaExpression_$1_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$MetaExpression_$1_$0$memo,
        );
    }
    public matchMetaExpression_$1_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$1_$0_1> {
        return this.matchLogicalOr($$dpth + 1, $$cr);
    }
    public matchMetaExpression_$1_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<MetaExpression_$1_$0_2> {
        return this.matchRecord($$dpth + 1, $$cr);
    }
    public matchLogicalOr($$dpth: number, $$cr?: ErrorTracker): Nullable<LogicalOr> {
        return this.memoise(
            () => {
                return this.run<LogicalOr>($$dpth,
                    () => {
                        let $scope$expr: Nullable<LogicalImplication>;
                        let $scope$tail: Nullable<LogicalOr_$0[]>;
                        let $$res: Nullable<LogicalOr> = null;
                        if (true
                            && ($scope$expr = this.matchLogicalImplication($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<LogicalOr_$0>(() => this.matchLogicalOr_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LogicalOr, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$LogicalOr$memo,
        );
    }
    public matchLogicalOr_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<LogicalOr_$0> {
        return this.memoise(
            () => {
                return this.run<LogicalOr_$0>($$dpth,
                    () => {
                        let $scope$expr: Nullable<LogicalImplication>;
                        let $$res: Nullable<LogicalOr_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\|\|)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchLogicalImplication($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LogicalOr_$0, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$LogicalOr_$0$memo,
        );
    }
    public matchLogicalImplication($$dpth: number, $$cr?: ErrorTracker): Nullable<LogicalImplication> {
        return this.memoise(
            () => {
                return this.run<LogicalImplication>($$dpth,
                    () => {
                        let $scope$expr: Nullable<LogicalAnd>;
                        let $scope$tail: Nullable<LogicalImplication_$0[]>;
                        let $$res: Nullable<LogicalImplication> = null;
                        if (true
                            && ($scope$expr = this.matchLogicalAnd($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<LogicalImplication_$0>(() => this.matchLogicalImplication_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LogicalImplication, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$LogicalImplication$memo,
        );
    }
    public matchLogicalImplication_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<LogicalImplication_$0> {
        return this.memoise(
            () => {
                return this.run<LogicalImplication_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<LogicalAnd>;
                        let $$res: Nullable<LogicalImplication_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:<?->)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchLogicalAnd($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LogicalImplication_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$LogicalImplication_$0$memo,
        );
    }
    public matchLogicalAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<LogicalAnd> {
        return this.memoise(
            () => {
                return this.run<LogicalAnd>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Equality>;
                        let $scope$tail: Nullable<LogicalAnd_$0[]>;
                        let $$res: Nullable<LogicalAnd> = null;
                        if (true
                            && ($scope$expr = this.matchEquality($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<LogicalAnd_$0>(() => this.matchLogicalAnd_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LogicalAnd, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$LogicalAnd$memo,
        );
    }
    public matchLogicalAnd_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<LogicalAnd_$0> {
        return this.memoise(
            () => {
                return this.run<LogicalAnd_$0>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Equality>;
                        let $$res: Nullable<LogicalAnd_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\&\&)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchEquality($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LogicalAnd_$0, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$LogicalAnd_$0$memo,
        );
    }
    public matchEquality($$dpth: number, $$cr?: ErrorTracker): Nullable<Equality> {
        return this.memoise(
            () => {
                return this.run<Equality>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Comparison>;
                        let $scope$tail: Nullable<Equality_$0[]>;
                        let $$res: Nullable<Equality> = null;
                        if (true
                            && ($scope$expr = this.matchComparison($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Equality_$0>(() => this.matchEquality_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Equality, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Equality$memo,
        );
    }
    public matchEquality_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Equality_$0> {
        return this.memoise(
            () => {
                return this.run<Equality_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<Comparison>;
                        let $$res: Nullable<Equality_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:<>|==)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchComparison($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Equality_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Equality_$0$memo,
        );
    }
    public matchComparison($$dpth: number, $$cr?: ErrorTracker): Nullable<Comparison> {
        return this.memoise(
            () => {
                return this.run<Comparison>($$dpth,
                    () => {
                        let $scope$expr: Nullable<BitwiseOr>;
                        let $scope$tail: Nullable<Comparison_$0[]>;
                        let $$res: Nullable<Comparison> = null;
                        if (true
                            && ($scope$expr = this.matchBitwiseOr($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Comparison_$0>(() => this.matchComparison_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Comparison, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Comparison$memo,
        );
    }
    public matchComparison_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Comparison_$0> {
        return this.memoise(
            () => {
                return this.run<Comparison_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<BitwiseOr>;
                        let $$res: Nullable<Comparison_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:<=>|[<>]=?)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchBitwiseOr($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Comparison_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Comparison_$0$memo,
        );
    }
    public matchBitwiseOr($$dpth: number, $$cr?: ErrorTracker): Nullable<BitwiseOr> {
        return this.memoise(
            () => {
                return this.run<BitwiseOr>($$dpth,
                    () => {
                        let $scope$expr: Nullable<BitwiseXor>;
                        let $scope$tail: Nullable<BitwiseOr_$0[]>;
                        let $$res: Nullable<BitwiseOr> = null;
                        if (true
                            && ($scope$expr = this.matchBitwiseXor($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<BitwiseOr_$0>(() => this.matchBitwiseOr_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.BitwiseOr, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$BitwiseOr$memo,
        );
    }
    public matchBitwiseOr_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<BitwiseOr_$0> {
        return this.memoise(
            () => {
                return this.run<BitwiseOr_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<BitwiseXor>;
                        let $$res: Nullable<BitwiseOr_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:\|)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchBitwiseXor($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.BitwiseOr_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$BitwiseOr_$0$memo,
        );
    }
    public matchBitwiseXor($$dpth: number, $$cr?: ErrorTracker): Nullable<BitwiseXor> {
        return this.memoise(
            () => {
                return this.run<BitwiseXor>($$dpth,
                    () => {
                        let $scope$expr: Nullable<BitwiseAnd>;
                        let $scope$tail: Nullable<BitwiseXor_$0[]>;
                        let $$res: Nullable<BitwiseXor> = null;
                        if (true
                            && ($scope$expr = this.matchBitwiseAnd($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<BitwiseXor_$0>(() => this.matchBitwiseXor_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.BitwiseXor, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$BitwiseXor$memo,
        );
    }
    public matchBitwiseXor_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<BitwiseXor_$0> {
        return this.memoise(
            () => {
                return this.run<BitwiseXor_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<BitwiseAnd>;
                        let $$res: Nullable<BitwiseXor_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:\?)`, $$dpth + 1, $$cr)) !== null
                            && this.negate(() => this.regexAccept(String.raw`(?:[!:])`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchBitwiseAnd($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.BitwiseXor_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$BitwiseXor_$0$memo,
        );
    }
    public matchBitwiseAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<BitwiseAnd> {
        return this.memoise(
            () => {
                return this.run<BitwiseAnd>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Shift>;
                        let $scope$tail: Nullable<BitwiseAnd_$0[]>;
                        let $$res: Nullable<BitwiseAnd> = null;
                        if (true
                            && ($scope$expr = this.matchShift($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<BitwiseAnd_$0>(() => this.matchBitwiseAnd_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.BitwiseAnd, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$BitwiseAnd$memo,
        );
    }
    public matchBitwiseAnd_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<BitwiseAnd_$0> {
        return this.memoise(
            () => {
                return this.run<BitwiseAnd_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<Shift>;
                        let $$res: Nullable<BitwiseAnd_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:\&)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchShift($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.BitwiseAnd_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$BitwiseAnd_$0$memo,
        );
    }
    public matchShift($$dpth: number, $$cr?: ErrorTracker): Nullable<Shift> {
        return this.memoise(
            () => {
                return this.run<Shift>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Additive>;
                        let $scope$tail: Nullable<Shift_$0[]>;
                        let $$res: Nullable<Shift> = null;
                        if (true
                            && ($scope$expr = this.matchAdditive($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Shift_$0>(() => this.matchShift_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Shift, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Shift$memo,
        );
    }
    public matchShift_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Shift_$0> {
        return this.memoise(
            () => {
                return this.run<Shift_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<Additive>;
                        let $$res: Nullable<Shift_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:<<|>>>?)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchAdditive($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Shift_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Shift_$0$memo,
        );
    }
    public matchAdditive($$dpth: number, $$cr?: ErrorTracker): Nullable<Additive> {
        return this.memoise(
            () => {
                return this.run<Additive>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Multiplicative>;
                        let $scope$tail: Nullable<Additive_$0[]>;
                        let $$res: Nullable<Additive> = null;
                        if (true
                            && ($scope$expr = this.matchMultiplicative($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Additive_$0>(() => this.matchAdditive_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Additive, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Additive$memo,
        );
    }
    public matchAdditive_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Additive_$0> {
        return this.memoise(
            () => {
                return this.run<Additive_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<Multiplicative>;
                        let $$res: Nullable<Additive_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:[+-])`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchMultiplicative($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Additive_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Additive_$0$memo,
        );
    }
    public matchMultiplicative($$dpth: number, $$cr?: ErrorTracker): Nullable<Multiplicative> {
        return this.memoise(
            () => {
                return this.run<Multiplicative>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Exponential>;
                        let $scope$tail: Nullable<Multiplicative_$0[]>;
                        let $$res: Nullable<Multiplicative> = null;
                        if (true
                            && ($scope$expr = this.matchExponential($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Multiplicative_$0>(() => this.matchMultiplicative_$0($$dpth + 1, $$cr), true)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Multiplicative, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Multiplicative$memo,
        );
    }
    public matchMultiplicative_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Multiplicative_$0> {
        return this.memoise(
            () => {
                return this.run<Multiplicative_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<Exponential>;
                        let $$res: Nullable<Multiplicative_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:[*%\\]|[+\/-]?\/)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchExponential($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Multiplicative_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Multiplicative_$0$memo,
        );
    }
    public matchExponential($$dpth: number, $$cr?: ErrorTracker): Nullable<Exponential> {
        return this.memoise(
            () => {
                return this.run<Exponential>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Composition>;
                        let $scope$tail: Nullable<Nullable<Exponential_$0>>;
                        let $$res: Nullable<Exponential> = null;
                        if (true
                            && ($scope$expr = this.matchComposition($$dpth + 1, $$cr)) !== null
                            && (($scope$tail = this.matchExponential_$0($$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.Exponential, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Exponential$memo,
        );
    }
    public matchExponential_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Exponential_$0> {
        return this.memoise(
            () => {
                return this.run<Exponential_$0>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Exponential>;
                        let $$res: Nullable<Exponential_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\^)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchExponential($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Exponential_$0, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Exponential_$0$memo,
        );
    }
    public matchComposition($$dpth: number, $$cr?: ErrorTracker): Nullable<Composition> {
        return this.memoise(
            () => {
                return this.run<Composition>($$dpth,
                    () => {
                        let $scope$expr: Nullable<HighOrderFunction>;
                        let $scope$tail: Nullable<Nullable<Composition_$0>>;
                        let $$res: Nullable<Composition> = null;
                        if (true
                            && ($scope$expr = this.matchHighOrderFunction($$dpth + 1, $$cr)) !== null
                            && (($scope$tail = this.matchComposition_$0($$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.Composition, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$Composition$memo,
        );
    }
    public matchComposition_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Composition_$0> {
        return this.memoise(
            () => {
                return this.run<Composition_$0>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Composition>;
                        let $$res: Nullable<Composition_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:;)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchComposition($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Composition_$0, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Composition_$0$memo,
        );
    }
    public matchHighOrderFunction($$dpth: number, $$cr?: ErrorTracker): Nullable<HighOrderFunction> {
        return this.memoise(
            () => {
                return this.run<HighOrderFunction>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Atom>;
                        let $scope$tail: Nullable<Nullable<HighOrderFunction_$0>>;
                        let $$res: Nullable<HighOrderFunction> = null;
                        if (true
                            && ($scope$expr = this.matchAtom($$dpth + 1, $$cr)) !== null
                            && (($scope$tail = this.matchHighOrderFunction_$0($$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.HighOrderFunction, expr: $scope$expr, tail: $scope$tail};
                        }
                        return $$res;
                    });
            },
            this.$scope$HighOrderFunction$memo,
        );
    }
    public matchHighOrderFunction_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<HighOrderFunction_$0> {
        return this.memoise(
            () => {
                return this.run<HighOrderFunction_$0>($$dpth,
                    () => {
                        let $scope$op: Nullable<string>;
                        let $scope$expr: Nullable<HighOrderFunction>;
                        let $$res: Nullable<HighOrderFunction_$0> = null;
                        if (true
                            && ($scope$op = this.regexAccept(String.raw`(?:=>>|=<=|=<<)`, $$dpth + 1, $$cr)) !== null
                            && ($scope$expr = this.matchHighOrderFunction($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.HighOrderFunction_$0, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$HighOrderFunction_$0$memo,
        );
    }
    public matchAtom($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom> {
        return this.memoise(
            () => {
                return this.run<Atom>($$dpth,
                    () => {
                        let $scope$op: Nullable<Nullable<string>>;
                        let $scope$expr: Nullable<Atom_$0>;
                        let $$res: Nullable<Atom> = null;
                        if (true
                            && (($scope$op = this.regexAccept(String.raw`(?:[~+-])`, $$dpth + 1, $$cr)) || true)
                            && ($scope$expr = this.matchAtom_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Atom, op: $scope$op, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Atom$memo,
        );
    }
    public matchAtom_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_$0> {
        return this.memoise(
            () => {
                return this.choice<Atom_$0>([
                    () => this.matchAtom_$0_1($$dpth + 1, $$cr),
                    () => this.matchAtom_$0_2($$dpth + 1, $$cr),
                    () => this.matchAtom_$0_3($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Atom_$0$memo,
        );
    }
    public matchAtom_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_$0_1> {
        return this.matchPrimitive($$dpth + 1, $$cr);
    }
    public matchAtom_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_$0_2> {
        return this.matchEvaluation($$dpth + 1, $$cr);
    }
    public matchAtom_$0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_$0_3> {
        return this.matchVector($$dpth + 1, $$cr);
    }
    public matchVector($$dpth: number, $$cr?: ErrorTracker): Nullable<Vector> {
        return this.memoise(
            () => {
                return this.run<Vector>($$dpth,
                    () => {
                        let $scope$items: Nullable<Nullable<Items>>;
                        let $$res: Nullable<Vector> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                            && (($scope$items = this.matchItems($$dpth + 1, $$cr)) || true)
                            && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = {kind: ASTKinds.Vector, items: $scope$items};
                        }
                        return $$res;
                    });
            },
            this.$scope$Vector$memo,
        );
    }
    public matchFVector($$dpth: number, $$cr?: ErrorTracker): Nullable<FVector> {
        return this.memoise(
            () => {
                return this.run<FVector>($$dpth,
                    () => {
                        let $scope$items: Nullable<Nullable<Items>>;
                        let $$res: Nullable<FVector> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                            && (($scope$items = this.matchItems($$dpth + 1, $$cr)) || true)
                            && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                        ) {
                            $$res = {kind: ASTKinds.FVector, items: $scope$items};
                        }
                        return $$res;
                    });
            },
            this.$scope$FVector$memo,
        );
    }
    public matchItems($$dpth: number, $$cr?: ErrorTracker): Nullable<Items> {
        return this.memoise(
            () => {
                return this.run<Items>($$dpth,
                    () => {
                        let $scope$head: Nullable<Expression>;
                        let $scope$tail: Nullable<Items_$0[]>;
                        let $scope$asList: Nullable<Nullable<string>>;
                        let $$res: Nullable<Items> = null;
                        if (true
                            && ($scope$head = this.matchExpression($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Items_$0>(() => this.matchItems_$0($$dpth + 1, $$cr), true)) !== null
                            && (($scope$asList = this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.Items, head: $scope$head, tail: $scope$tail, asList: $scope$asList};
                        }
                        return $$res;
                    });
            },
            this.$scope$Items$memo,
        );
    }
    public matchItems_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Items_$0> {
        return this.memoise(
            () => {
                return this.run<Items_$0>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Expression>;
                        let $$res: Nullable<Items_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchExpression($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Items_$0, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Items_$0$memo,
        );
    }
    public matchEvaluation($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation> {
        return this.memoise(
            () => {
                return this.run<Evaluation>($$dpth,
                    () => {
                        let $scope$eager: Nullable<Nullable<string>>;
                        let $scope$expr: Nullable<Evaluation_$0>;
                        let $$res: Nullable<Evaluation> = null;
                        if (true
                            && (($scope$eager = this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr)) || true)
                            && ($scope$expr = this.matchEvaluation_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Evaluation, eager: $scope$eager, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Evaluation$memo,
        );
    }
    public matchEvaluation_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation_$0> {
        return this.memoise(
            () => {
                return this.choice<Evaluation_$0>([
                    () => this.matchEvaluation_$0_1($$dpth + 1, $$cr),
                    () => this.matchEvaluation_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Evaluation_$0$memo,
        );
    }
    public matchEvaluation_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation_$0_1> {
        return this.matchLambda($$dpth + 1, $$cr);
    }
    public matchEvaluation_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation_$0_2> {
        return this.run<Evaluation_$0_2>($$dpth,
            () => {
                let $scope$label: Nullable<MARKER>;
                let $scope$vector: Nullable<Nullable<Evaluation_$0_$0>>;
                let $$res: Nullable<Evaluation_$0_2> = null;
                if (true
                    && ($scope$label = this.matchMARKER($$dpth + 1, $$cr)) !== null
                    && (($scope$vector = this.matchEvaluation_$0_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.Evaluation_$0_2, label: $scope$label, vector: $scope$vector};
                }
                return $$res;
            });
    }
    public matchEvaluation_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation_$0_$0> {
        return this.memoise(
            () => {
                return this.choice<Evaluation_$0_$0>([
                    () => this.matchEvaluation_$0_$0_1($$dpth + 1, $$cr),
                    () => this.matchEvaluation_$0_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Evaluation_$0_$0$memo,
        );
    }
    public matchEvaluation_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation_$0_$0_1> {
        return this.matchVector($$dpth + 1, $$cr);
    }
    public matchEvaluation_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Evaluation_$0_$0_2> {
        return this.matchFVector($$dpth + 1, $$cr);
    }
    public matchLambda($$dpth: number, $$cr?: ErrorTracker): Nullable<Lambda> {
        return this.memoise(
            () => {
                return this.run<Lambda>($$dpth,
                    () => {
                        let $scope$expr: Nullable<Lambda_$0>;
                        let $$res: Nullable<Lambda> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:\.)`, $$dpth + 1, $$cr) !== null
                            && ($scope$expr = this.matchLambda_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Lambda, expr: $scope$expr};
                        }
                        return $$res;
                    });
            },
            this.$scope$Lambda$memo,
        );
    }
    public matchLambda_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Lambda_$0> {
        return this.memoise(
            () => {
                return this.choice<Lambda_$0>([
                    () => this.matchLambda_$0_1($$dpth + 1, $$cr),
                    () => this.matchLambda_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Lambda_$0$memo,
        );
    }
    public matchLambda_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Lambda_$0_1> {
        return this.run<Lambda_$0_1>($$dpth,
            () => {
                let $scope$body: Nullable<LambdaBody>;
                let $$res: Nullable<Lambda_$0_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && ($scope$body = this.matchLambdaBody($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Lambda_$0_1, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchLambda_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Lambda_$0_2> {
        return this.run<Lambda_$0_2>($$dpth,
            () => {
                let $scope$body: Nullable<LambdaBody>;
                let $$res: Nullable<Lambda_$0_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$body = this.matchLambdaBody($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Lambda_$0_2, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchLambdaBody($$dpth: number, $$cr?: ErrorTracker): Nullable<LambdaBody> {
        return this.memoise(
            () => {
                return this.run<LambdaBody>($$dpth,
                    () => {
                        let $scope$parameters: Nullable<Nullable<Parameters>>;
                        let $scope$body: Nullable<Expression>;
                        let $scope$partial: Nullable<Nullable<LambdaBody_$0>>;
                        let $$res: Nullable<LambdaBody> = null;
                        if (true
                            && (($scope$parameters = this.matchParameters($$dpth + 1, $$cr)) || true)
                            && this.regexAccept(String.raw`(?:;)`, $$dpth + 1, $$cr) !== null
                            && ($scope$body = this.matchExpression($$dpth + 1, $$cr)) !== null
                            && (($scope$partial = this.matchLambdaBody_$0($$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.LambdaBody, parameters: $scope$parameters, body: $scope$body, partial: $scope$partial};
                        }
                        return $$res;
                    });
            },
            this.$scope$LambdaBody$memo,
        );
    }
    public matchLambdaBody_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<LambdaBody_$0> {
        return this.memoise(
            () => {
                return this.run<LambdaBody_$0>($$dpth,
                    () => {
                        let $scope$args: Nullable<Vector>;
                        let $$res: Nullable<LambdaBody_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:;)`, $$dpth + 1, $$cr) !== null
                            && ($scope$args = this.matchVector($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.LambdaBody_$0, args: $scope$args};
                        }
                        return $$res;
                    });
            },
            this.$scope$LambdaBody_$0$memo,
        );
    }
    public matchParameters($$dpth: number, $$cr?: ErrorTracker): Nullable<Parameters> {
        return this.memoise(
            () => {
                return this.run<Parameters>($$dpth,
                    () => {
                        let $scope$mark: Nullable<MARKER>;
                        let $scope$tail: Nullable<Parameters_$0[]>;
                        let $scope$variadic: Nullable<Nullable<string>>;
                        let $$res: Nullable<Parameters> = null;
                        if (true
                            && ($scope$mark = this.matchMARKER($$dpth + 1, $$cr)) !== null
                            && ($scope$tail = this.loop<Parameters_$0>(() => this.matchParameters_$0($$dpth + 1, $$cr), true)) !== null
                            && (($scope$variadic = this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, $$cr)) || true)
                        ) {
                            $$res = {kind: ASTKinds.Parameters, mark: $scope$mark, tail: $scope$tail, variadic: $scope$variadic};
                        }
                        return $$res;
                    });
            },
            this.$scope$Parameters$memo,
        );
    }
    public matchParameters_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Parameters_$0> {
        return this.memoise(
            () => {
                return this.run<Parameters_$0>($$dpth,
                    () => {
                        let $scope$mark: Nullable<MARKER>;
                        let $$res: Nullable<Parameters_$0> = null;
                        if (true
                            && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                            && ($scope$mark = this.matchMARKER($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = {kind: ASTKinds.Parameters_$0, mark: $scope$mark};
                        }
                        return $$res;
                    });
            },
            this.$scope$Parameters_$0$memo,
        );
    }
    public matchPrimitive($$dpth: number, $$cr?: ErrorTracker): Nullable<Primitive> {
        return this.memoise(
            () => {
                return this.choice<Primitive>([
                    () => this.matchPrimitive_1($$dpth + 1, $$cr),
                    () => this.matchPrimitive_2($$dpth + 1, $$cr),
                    () => this.matchPrimitive_3($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$Primitive$memo,
        );
    }
    public matchPrimitive_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Primitive_1> {
        return this.matchNUMBER($$dpth + 1, $$cr);
    }
    public matchPrimitive_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Primitive_2> {
        return this.matchSTRING($$dpth + 1, $$cr);
    }
    public matchPrimitive_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Primitive_3> {
        return this.matchTRILEAN($$dpth + 1, $$cr);
    }
    public matchNUMBER($$dpth: number, $$cr?: ErrorTracker): Nullable<NUMBER> {
        return this.memoise(
            () => {
                return this.run<NUMBER>($$dpth,
                    () => {
                        let $scope$text: Nullable<string>;
                        let $$res: Nullable<NUMBER> = null;
                        if (true
                            && ($scope$text = this.regexAccept(String.raw`(?:[0-9]*\.[0-9]+|[0-9]+\.?)`, $$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = new NUMBER($scope$text);
                        }
                        return $$res;
                    });
            },
            this.$scope$NUMBER$memo,
        );
    }
    public matchSTRING($$dpth: number, $$cr?: ErrorTracker): Nullable<STRING> {
        return this.memoise(
            () => {
                return this.run<STRING>($$dpth,
                    () => {
                        let $scope$text: Nullable<STRING_$0>;
                        let $$res: Nullable<STRING> = null;
                        if (true
                            && ($scope$text = this.matchSTRING_$0($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = new STRING($scope$text);
                        }
                        return $$res;
                    });
            },
            this.$scope$STRING$memo,
        );
    }
    public matchSTRING_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<STRING_$0> {
        return this.memoise(
            () => {
                return this.choice<STRING_$0>([
                    () => this.matchSTRING_$0_1($$dpth + 1, $$cr),
                    () => this.matchSTRING_$0_2($$dpth + 1, $$cr),
                ]);
            },
            this.$scope$STRING_$0$memo,
        );
    }
    public matchSTRING_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<STRING_$0_1> {
        return this.regexAccept(String.raw`(?:"(\\"|[^\\"])*")`, $$dpth + 1, $$cr);
    }
    public matchSTRING_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<STRING_$0_2> {
        return this.regexAccept(String.raw`(?:\'(\\\'|[^\\\'])*\')`, $$dpth + 1, $$cr);
    }
    public matchMARKER($$dpth: number, $$cr?: ErrorTracker): Nullable<MARKER> {
        return this.memoise(
            () => {
                return this.run<MARKER>($$dpth,
                    () => {
                        let $scope$text: Nullable<string>;
                        let $$res: Nullable<MARKER> = null;
                        if (true
                            && ($scope$text = this.regexAccept(String.raw`(?:@?[a-zA-Z_][a-zA-Z0-9_]*|[?!|<>&=:+*%\\\/~$private _\^-]+)`, $$dpth + 1, $$cr)) !== null
                            && this.negate(() => this.matchTRILEAN($$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = new MARKER($scope$text);
                        }
                        return $$res;
                    });
            },
            this.$scope$MARKER$memo,
        );
    }
    public matchTRILEAN($$dpth: number, $$cr?: ErrorTracker): Nullable<TRILEAN> {
        return this.memoise(
            () => {
                return this.run<TRILEAN>($$dpth,
                    () => {
                        let $scope$text: Nullable<string>;
                        let $$res: Nullable<TRILEAN> = null;
                        if (true
                            && ($scope$text = this.regexAccept(String.raw`(?:false|nil|true)`, $$dpth + 1, $$cr)) !== null
                        ) {
                            $$res = new TRILEAN($scope$text);
                        }
                        return $$res;
                    });
            },
            this.$scope$TRILEAN$memo,
        );
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchMExpression(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchMExpression(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchMExpression(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<MExpression>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}