<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>PA Main 2011</title>
  <style>
  html, body, #map-div {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  </style>
  <link href="../../css/jquery-ui/smoothness/jquery-ui.custom.css" media="screen" rel="stylesheet" type="text/css" />
  <link href="../../css/defaultUI.css" media="screen" rel="stylesheet" type="text/css"></link>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
  <script src="../../js/jquery/jquery-ui.custom.min.js" type="text/javascript"></script>
  <script src="http://maps.googleapis.com/maps/api/js?sensor=false"></script>
  <script type="text/javascript" src="../../js/CanvasLayer.js"></script>
  <script type="text/javascript" src="../../js/utils.js"></script>
  <script type="text/javascript" src="../../js/stats.min.js"></script>
  <script type="text/javascript" src="../webgl-timemachine/Glb.js"></script>
  <script src="dat.gui.min.js"></script>
  <script id="point-vertex-shader" type="x-shader/x-vertex">
    attribute vec2 hCentroid; // Centroid of the residence census block
    attribute vec2 wCentroid; // Centroid of the workplace census block

    attribute float aTime;
    //attribute float aS000; // Total number of jobs
    attribute float aDist; // Distance in meters between workplace and residence centroids
    attribute float aSe01; // Number of jobs with earnings $1250/month or less
    attribute float aSe02; // Number of jobs with earnings $1251/month to $3333/month
    attribute float aSe03; // Number of jobs with earnings greater than $3333/month

    uniform bool filterDist;
    uniform bool showSe01;
    uniform bool showSe02;
    uniform bool showSe03;

    uniform float uDist;
    uniform float uSize;
    uniform float uZoom;
    uniform mat4 mapMatrix;

    varying float vSe01;
    varying float vSe02;
    varying float vSe03;

    float fX(float x, float deltaX, float t) {
      return x + deltaX * t;
    }

    float fY(float y, float deltaY, float t) {
      return y + deltaY * t;
    }

    void main() {
      float fx = fX(hCentroid.x, wCentroid.x - hCentroid.x, aTime);
      float fy = fY(hCentroid.y, wCentroid.y - hCentroid.y, aTime);

      vec4 position = mapMatrix * vec4(fx, fy, 0, 1);

      if (filterDist && aDist >= uDist) {
          position = vec4(-1.,-1.,-1.,-1.);
      }
      if (!showSe01 && aSe01 > 0.) {
        position = vec4(-1.,-1.,-1.,-1.);
      }
      if (!showSe02 && aSe02 > 0.) {
        position = vec4(-1.,-1.,-1.,-1.);
      }
      if (!showSe03 && aSe03 > 0.) {
        position = vec4(-1.,-1.,-1.,-1.);
      }
      gl_Position = position;
      gl_PointSize = uSize;

      vSe01 = aSe01;
      vSe02 = aSe02;
      vSe03 = aSe03;
    }
  </script>
  <script id="point-fragment-shader" type="x-shader/x-fragment">
    precision mediump float;

    uniform bool showEarnings;

    varying float vSe01;
    varying float vSe02;
    varying float vSe03;

    vec4 setColor(vec4 color, float dist, float hardFraction) {
      return color * clamp((0.5 - dist) / (0.5 - 0.5 * hardFraction), 0., 1.);
    }

    void main() {
      vec4 se01Color = vec4(.08,.45,.92,.45);
      vec4 se02Color = vec4(.14,.75,.18,.45);
      vec4 se03Color = vec4(.89,.12,.24,.45);
      vec4 color = vec4(.08,.55,.08,1.);
      //float dist = length(gl_PointCoord.xy - vec2(.5,.5));
      //gl_FragColor = setColor(color, dist, .4);

      if (showEarnings) {
        if (vSe01 > 0.) {
          color = se01Color;
        }
        if (vSe02 > 0.) {
          color = se02Color;
        }
        if (vSe03 > 0.) {
          color = se03Color;
        }
      }
      gl_FragColor = color;
    }
  </script>

  <script>
    /* begin stats */
    var stats = new Stats();
    stats.setMode(0); // 0: fps, 1: ms
    // Align top-left
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    /* end stats */

    var map;
    var canvasLayer;
    var gl;
    var pointCount;
    var data;
    var arrayBuffer;
    var ready;
    var program;
    var glb;
    var pixelsToWebGLMatrix = new Float32Array(16);
    var mapMatrix = new Float32Array(16);

    var uDist = 10000.;
    var filterDist = false;
    var showEarnings = false;

    var gui;
    var lodesOptions;

    var LodesOptions = function() {
      this.doPulse = false;
      this.totalTime = 5000;
      this.dwellTime = 1000;
      this.filterDist = false;
      this.uDist = 10000.;
      this.animate = 'home';
      this.se01 = true;
      this.se02 = true;
      this.se03 = true;
      this.showEarnings = true;

    };
    function initGui() {
      lodesOptions = new LodesOptions();
      var gui = new dat.GUI();
      var f1 = gui.addFolder('Animation');
      f1.add(lodesOptions, 'animate', { animate: 'animate', home: 'home', work: 'work' } );
      f1.add(lodesOptions,'doPulse');
      f1.add(lodesOptions, 'totalTime', 1000, 30000).step(1000);
      f1.add(lodesOptions, 'dwellTime', 0, 2000).step(100);
      var f2 = gui.addFolder('Distance');
      f2.add(lodesOptions, 'filterDist');
      f2.add(lodesOptions, 'uDist',0,500000);
      var f2 = gui.addFolder('Earnings');
      f2.add(lodesOptions, 'se01');
      f2.add(lodesOptions, 'se02');
      f2.add(lodesOptions, 'se03');
      f2.add(lodesOptions, 'showEarnings');

    }



    /**
    * Latitude-longitude-date data is a series of 2 32-bit floats and 1 32-bit integer little-endian encoded.
    * Each lat-lng-date grouping represents a well.
    */

    var dataURL = "pa_od_main_jt00_2011-all-points.bin";

    function load(url) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url);
      xhr.responseType = 'arraybuffer';
      xhr.onload = function() {
        var float32Array = new Float32Array(this.response);
        setData(float32Array);
      }
      xhr.send();
    }

    function setData(buffer) {
      pointCount = buffer.length / 9;

      data = buffer;
      arrayBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, arrayBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      var attributeLoc = gl.getAttribLocation(program, 'wCentroid');
      gl.enableVertexAttribArray(attributeLoc);
      gl.vertexAttribPointer(attributeLoc, 2, gl.FLOAT, false, 36, 0);

      var attributeLoc = gl.getAttribLocation(program, 'hCentroid');
      gl.enableVertexAttribArray(attributeLoc);
      gl.vertexAttribPointer(attributeLoc, 2, gl.FLOAT, false, 36, 8);

      var attributeLoc = gl.getAttribLocation(program, 'aDist');
      gl.enableVertexAttribArray(attributeLoc);
      gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 16);

      //var attributeLoc = gl.getAttribLocation(program, 'aS000');
      //gl.enableVertexAttribArray(attributeLoc);
      //gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 20);

      var attributeLoc = gl.getAttribLocation(program, 'aSe01');
      gl.enableVertexAttribArray(attributeLoc);
      gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 24);

      var attributeLoc = gl.getAttribLocation(program, 'aSe02');
      gl.enableVertexAttribArray(attributeLoc);
      gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 28);

      var attributeLoc = gl.getAttribLocation(program, 'aSe03');
      gl.enableVertexAttribArray(attributeLoc);
      gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 32);

      ready = true;
    }

    var then = new Date();
    var inMainLoop = false;
    var inStartDwell = true;
    var inEndDwell = false;
    var countryPointSizePixels = 1;
    var blockPointSizePixels = 10;
    var pointSize;
    //var doPulse = false;
    var pulse  = false;


    function draw(transform) {
      if (ready) {
        gl.lineWidth(2);
        gl.useProgram(program);

        if (lodesOptions.animate == 'animate') {
          var now = new Date();
          var deltaTime = now.getTime() - then.getTime();
          var step = deltaTime/lodesOptions.totalTime;
          if (inMainLoop) {
            if (lodesOptions.doPulse) {
              if (pulse) {
                step = 1. - step;
              }
            } else if (pulse) {
              pulse = false;
            }

            if (deltaTime >= lodesOptions.totalTime) {
              then = new Date();
              inMainLoop = false;
              if (lodesOptions.doPulse && pulse) {
                inStartDwell = true;
              } else {
                inEndDwell = true;
              }
            }
          }
          else if (inStartDwell) {
            step = 0.;
            if (deltaTime >= lodesOptions.dwellTime) {
              inStartDwell = false;
              inMainLoop = true;
              then = new Date();
              if (lodesOptions.doPulse) {
                pulse = false;
              }
            }
          }
          else {
            step = 1.;
            if (deltaTime >= lodesOptions.dwellTime) {
              inEndDwell = false;
              then = new Date();
              if (lodesOptions.doPulse) {
                inMainLoop = true;
                pulse = true;
              } else {
                inStartDwell = true;
              }
            }
          }
          step = Math.min(Math.max(step, 0.),1.);

        } else if (lodesOptions.animate == 'home'){
            step = 0.;
        } else {
          step = 1.;
        }

        pointSize = countryPointSizePixels * Math.pow(blockPointSizePixels / countryPointSizePixels, (map.zoom - 7) / (21 - 7));

        var aTime = gl.getAttribLocation(program, "aTime");
        gl.vertexAttrib1f(aTime, step);

        var sizeLoc = gl.getUniformLocation(program, 'uSize');
        gl.uniform1f(sizeLoc, pointSize);

        var zoomLoc = gl.getUniformLocation(program, 'uZoom');
        gl.uniform1f(zoomLoc, map.zoom);

        var filterDistLoc = gl.getUniformLocation(program, 'filterDist');
        gl.uniform1i(filterDistLoc, lodesOptions.filterDist);

        var showEarningsLoc = gl.getUniformLocation(program, 'showEarnings');
        gl.uniform1i(showEarningsLoc, lodesOptions.showEarnings);

        var showSe01Loc = gl.getUniformLocation(program, 'showSe01');
        gl.uniform1i(showSe01Loc, lodesOptions.se01);

        var showSe02Loc = gl.getUniformLocation(program, 'showSe02');
        gl.uniform1i(showSe02Loc, lodesOptions.se02);

        var showSe03Loc = gl.getUniformLocation(program, 'showSe03');
        gl.uniform1i(showSe03Loc, lodesOptions.se03);

        var matrixLoc = gl.getUniformLocation(program, 'mapMatrix');
        gl.uniformMatrix4fv(matrixLoc, false, transform);

        var uDistLoc = gl.getUniformLocation(program, 'uDist');
        gl.uniform1f(uDistLoc, lodesOptions.uDist);


        gl.bindBuffer(gl.ARRAY_BUFFER, arrayBuffer);

        var attributeLoc = gl.getAttribLocation(program, 'wCentroid');
        gl.enableVertexAttribArray(attributeLoc);
        gl.vertexAttribPointer(attributeLoc, 2, gl.FLOAT, false, 36, 0);

        var attributeLoc = gl.getAttribLocation(program, 'hCentroid');
        gl.enableVertexAttribArray(attributeLoc);
        gl.vertexAttribPointer(attributeLoc, 2, gl.FLOAT, false, 36, 8);

        var attributeLoc = gl.getAttribLocation(program, 'aDist');
        gl.enableVertexAttribArray(attributeLoc);
        gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 16);

        //var attributeLoc = gl.getAttribLocation(program, 'aS000');
        //gl.enableVertexAttribArray(attributeLoc);
        //gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 20);

        var attributeLoc = gl.getAttribLocation(program, 'aSe01');
        gl.enableVertexAttribArray(attributeLoc);
        gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 24);

        var attributeLoc = gl.getAttribLocation(program, 'aSe02');
        gl.enableVertexAttribArray(attributeLoc);
        gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 28);

        var attributeLoc = gl.getAttribLocation(program, 'aSe03');
        gl.enableVertexAttribArray(attributeLoc);
        gl.vertexAttribPointer(attributeLoc, 1, gl.FLOAT, false, 36, 32);

        gl.drawArrays(gl.POINTS, 0, pointCount);
      }
    }

    function update() {
      stats.begin();
      if (ready) {

        gl.clear(gl.COLOR_BUFFER_BIT);

        var mapProjection = map.getProjection();

        /**
        * We need to create a transformation that takes world coordinate
        * points in the pointArrayBuffer to the coodinates WebGL expects.
        * 1. Start with second half in pixelsToWebGLMatrix, which takes pixel
        *     coordinates to WebGL coordinates.
        * 2. Scale and translate to take world coordinates to pixel coords
        * see https://developers.google.com/maps/documentation/javascript/maptypes#MapCoordinate
        */

        // copy pixel->webgl matrix
        mapMatrix.set(pixelsToWebGLMatrix);

        // Scale to current zoom (worldCoords * 2^zoom)
        var scale = canvasLayer.getMapScale();
        scaleMatrix(mapMatrix, scale, scale);

        var translation = canvasLayer.getMapTranslation();
        translateMatrix(mapMatrix, translation.x, translation.y);
        draw(mapMatrix);
      }
      stats.end();
    }

    function resize() {
      var w = gl.canvas.width;
      var h = gl.canvas.height;
      gl.viewport(0, 0, w, h);

      // matrix which maps pixel coordinates to WebGL coordinates
      pixelsToWebGLMatrix.set([2/w, 0,   0, 0,
        0,  -2/h, 0, 0,
        0,   0,   0, 0,
        -1,   1,   0, 1]);
    }

    function initMap() {
      // initialize the map
      var mapOptions = {
        zoom: 7,
        center: new google.maps.LatLng(41.17, -77.21),
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        styles: [
          {
            "featureType": "road",
            "elementType": "labels",
            "stylers": [
              { "visibility": "off" }
            ]
          },{
            "featureType": "road",
            "stylers": [
              { "color": "#808080" },
              { "weight": 0.2 }
            ]
          },{
            "featureType": "poi",
            "stylers": [
              { "visibility": "off" }
            ]
          },{
            "featureType": "landscape",
            "stylers": [
              { "visibility": "on" },
              { "lightness": 91 }
            ]
          }
        ]
      };
      var mapDiv = document.getElementById('map-div');
      map = new google.maps.Map(mapDiv, mapOptions);

      // initialize the canvasLayer
      var canvasLayerOptions = {
        map: map,
        resizeHandler: resize,
        animate: true,
        updateHandler: update
      };
      canvasLayer = new CanvasLayer(canvasLayerOptions);
      gl = canvasLayer.canvas.getContext('experimental-webgl');
      //gl.enable(gl.BLEND);
      //gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
      gl.enable( gl.BLEND );
      gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
      gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

      glb = new Glb(gl);
      program = glb.programFromSources(document.getElementById('point-vertex-shader').text,
      document.getElementById('point-fragment-shader').text);
      load(dataURL);
      window.addEventListener('resize', function () {  google.maps.event.trigger(map, 'resize') }, false);

    }

    function init() {
      initMap();
      initGui();
      document.body.appendChild(stats.domElement);
    }

    document.addEventListener('DOMContentLoaded', init, false);
  </script>

  </head>
  <body>
    <div id="map-div"></div>
  </body>
</html>
